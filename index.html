<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EPG dobleM - 5.6</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
    <style>
        :root {
            --color-bg-dark-start: #1e1e1e;
            --color-bg-dark-end: #2b2b2b;
            --color-bg-light-start: #f4f4f4;
            --color-bg-light-end: #e6e6e6;
            --color-primary: #00e5ff;
            --color-primary-hover: #00bcd4;
            --color-text-dark: #fff;
            --color-text-light: #000;
            --color-text-muted-dark: #ccc;
            --color-text-muted-light: #333;
            --color-bg-input-dark: #444;
            --color-border-input-dark: #777;
            --color-bg-controls-dark: #2e2e2e;
            --color-bg-controls-light: #ddd;
            --color-bg-card-dark: #1a1a1a;
            --color-bg-card-light: #fff;
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--color-text-dark);
            background: linear-gradient(180deg, var(--color-bg-dark-start), var(--color-bg-dark-end));
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            color: var(--color-primary);
            margin-bottom: 20px;
        }

        #dateFilter {
            width: auto;
            min-width: 110px;
            max-width: 140px;
            padding: 6px 8px;
            font-size: 0.95em;
            box-sizing: border-box;
        }

        #hourFilter {
            width: auto;
            min-width: 90px;
            max-width: 120px;
            padding: 6px 8px;
            font-size: 0.85em;
            box-sizing: border-box;
        }

        #resetFiltersBtn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            padding: 0;
            font-size: 1.2em;
            line-height: 36px;
            text-align: center;
            cursor: pointer;
            border: none;
            background-color: var(--color-primary);
            color: #000;
            transition: background-color 0.3s;
            margin-left: 6px;
        }

        #resetFiltersBtn:hover {
            background-color: var(--color-primary-hover);
        }


        #controls {
            margin-bottom: 25px;
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            /* background: var(--color-bg-controls-dark); */
            /* box-shadow: 0 0 8px rgba(0, 0, 0, 0.3); */
        }

        input[type="text"],
        select {
            padding: 10px;
            margin: 8px;
            border-radius: 6px;
            border: 1px solid var(--color-border-input-dark);
            background-color: var(--color-bg-input-dark);
            color: var(--color-text-dark);
            font-size: 0.95em;
            cursor: text;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        button {
            font-size: 1em;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background-color: var(--color-primary);
            color: #000;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--color-primary-hover);
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        #result-count {
            text-align: center;
            margin: 15px 0;
            font-size: 0.95em;
            color: var(--color-text-muted-dark);
        }

        label {
            font-size: 0.95em;
            color: #ddd;
        }

        .pagination-btn {
            margin: 10px 5px;
        }

        #data-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
        }

        .program-card {
            background-color: var(--color-bg-card-dark);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 229, 255, 0.3);
            display: flex;
            flex-direction: column;
            color: var(--color-text-dark);
            transition: box-shadow 0.3s ease;
        }

        .program-card:hover {
            box-shadow: 0 4px 16px rgba(0, 229, 255, 0.6);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
            margin-bottom: 12px;
        }

        .card-info {
            display: flex;
            gap: 10px;
            align-items: baseline;
            color: var(--color-text-muted-dark);
            font-size: 0.9em;
            flex-wrap: wrap;
        }

        .card-date {
            display: block;
            font-weight: bold;
            color: var(--color-primary);
            font-size: 1.0em;
        }

        .card-time {
            display: block;
            color: var(--color-text-dark);
            font-weight: bold;
            font-size: 0.9em;
        }

        .card-time .duration {
            font-size: 0.8em;
            color: var(--color-text-muted-dark);
            margin-left: 5px;
        }

        .card-channel {
            display: flex;
            align-items: center;
            min-width: 120px;
            flex-direction: row;
        }

        .card-channel img {
            margin-right: 2px;
            height: 32px;
            width: auto;
            max-width: 60px;
            object-fit: contain;
            border-radius: 1px;
            margin: 5;
            padding: 0;
        }

        .channel-name {
            font-size: 0.65em;
            color: var(--color-text-muted-dark);
            margin-right: 1px;
        }

        .card-body {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .card-images {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .card-images img {
            width: 90px;
            border-radius: 6px;
            object-fit: contain;
        }

        .card-text {
            flex: 1;
            min-width: 200px;
        }

        .card-text .title {
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 5px;
            color: var(--color-text-dark);
        }

        .card-text .description {
            font-size: 0.85em;
            color: var(--color-text-muted-dark);
            white-space: pre-wrap;
        }

        #top-buttons {
            display: inline-flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: nowrap;
            /* que no se envuelvan */
        }

        input[type="text"],
        select,
        input[type="date"],
        input[type="number"] {
            padding: 10px;
            margin: 8px;
            border-radius: 6px;
            border: 1px solid var(--color-border-input-dark);
            background-color: var(--color-bg-input-dark);
            color: var(--color-text-dark);
            font-size: 0.95em;
            cursor: text;
        }

        #date-hour-filters {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }

        #date-hour-filters input,
        #date-hour-filters select {
            flex: 1;
            min-width: 150px;
        }


        /* Loader spinner styles moved to CSS */
        #loader-spinner {
            display: inline-block;
            border: 4px solid var(--color-primary);
            border-top: 4px solid transparent;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        /* Light mode overrides */
        body.light-mode {
            background: linear-gradient(180deg, var(--color-bg-light-start), var(--color-bg-light-end));
            color: var(--color-text-light);
        }

        body.light-mode .program-card {
            background-color: var(--color-bg-card-light);
            color: var(--color-text-light);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            /* Sombra m√°s suave para modo claro */
        }

        body.light-mode .program-card:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            /* Sombra m√°s suave al pasar el rat√≥n */
        }

        body.light-mode .card-date,
        body.light-mode .card-time,
        body.light-mode .card-text .title {
            color: var(--color-text-light);
        }

        body.light-mode .card-text .description,
        body.light-mode .channel-name,
        body.light-mode #result-count {
            color: var(--color-text-muted-light);
        }

        body.light-mode button {
            background-color: var(--color-primary-hover);
            color: var(--color-text-light);
            /* Asegura texto oscuro en botones claros */
        }

        body.light-mode .card-date,
        body.light-mode .card-time,
        body.light-mode .card-text .title {
            color: var(--color-text-light);
            /* Asegura que la fecha, hora y t√≠tulo sean oscuros */
        }

        /* --- Estilos para los Controles (filtros) en modo claro --- */
        body.light-mode input[type="text"],
        body.light-mode select,
        body.light-mode input[type="date"],
        body.light-mode input[type="number"] {
            background-color: var(--color-bg-controls-light);
            /* Fondo m√°s claro para inputs/selects */
            border-color: var(--color-border-input-dark);
            /* Borde que contraste */
            color: var(--color-text-light);
            /* Texto oscuro en inputs */
        }

        body.light-mode input[type="text"]:focus,
        body.light-mode select:focus,
        body.light-mode input[type="date"]:focus,
        body.light-mode input[type="number"]:focus {
            outline: none;
            border-color: var(--color-primary);
            /* Borde al enfocar, usando el color primario */
        }

        body.light-mode #controls {
            background: var(--color-bg-controls-light);
            /* Fondo para la secci√≥n de controles */
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.1);
            /* Sombra suave para controles */
        }

        body.light-mode label {
            /* Asegura el color del texto de la etiqueta en modo claro */
            color: var(--color-text-muted-light);
        }

        body.light-mode #resetFiltersBtn {
            background-color: var(--color-primary);
            /* Color del bot√≥n de reset */
            color: #000;
            /* Texto negro */
        }

        body.light-mode #resetFiltersBtn:hover {
            background-color: var(--color-primary-hover);
            /* Hover para el bot√≥n de reset */
        }

        /* --- Estilos de la Grilla en modo claro --- */
        body.light-mode #grid-container table {
            border: 1px solid var(--color-border-input-dark);
            /* Borde exterior de la tabla */
        }

        body.light-mode #grid-container th {
            background-color: var(--color-bg-controls-light);
            /* Fondo de los encabezados de la tabla */
            color: var(--color-text-light);
            /* Texto de los encabezados */
            border: 1px solid var(--color-border-input-dark);

            /* PROPIEDADES STICKY A√ëADIDAS */
            position: sticky;
            /* NUEVA L√çNEA */
            left: 0;
            /* NUEVA L√çNEA */
            z-index: 10;
            /* NUEVA L√çNEA */
        }

        body.light-mode #grid-container td {
            border: 1px solid var(--color-border-input-dark);
            /* Borde de las celdas de la grilla */
            color: var(--color-text-light);
            background-color: #ffffff;
            /* Las celdas VAC√çAS por defecto ser√°n BLANCAS */
        }

        body.light-mode #grid-container td[style*="background: rgb(51, 51, 51)"] {
            /* Celda con PROGRAMA (en modo oscuro ten√≠a #333) */
            background-color: #f0f0f0 !important;
            /* Fondo GRIS CLARO para las celdas con CONTENIDO de programa */
            color: var(--color-text-light);
        }

        body.light-mode #grid-container td[style*="background: rgb(34, 34, 34)"] {
            /* Celda del CANAL (en modo oscuro ten√≠a #222) */
            background-color: #e0e0e0 !important;
            /* Fondo GRIS MEDIO para el nombre del canal */
            color: var(--color-text-light);

            /* PROPIEDADES STICKY A√ëADIDAS */
            position: sticky;
            /* NUEVA L√çNEA */
            left: 0;
            /* NUEVA L√çNEA */
            z-index: 9;
            /* NUEVA L√çNEA */
        }

        body.light-mode #grid-container td>div {
            /* T√≠tulo del programa en grilla */
            color: var(--color-text-light);
        }

        body.light-mode #grid-container td>div:last-child {
            /* Hora del programa en grilla */
            color: var(--color-text-light) !important;
            /* <--- ¬°A√ëADIDO !important! */
        }

        /* --- ESTILOS ADICIONALES PARA MODO OSCURO (STICKY) --- */
        #grid-container th {
            /* Encabezado fijo (para el scroll vertical, si se aplica) */
            z-index: 10;
            position: sticky;
            top: 0;
            /* Si quieres que el encabezado de las horas tambi√©n sea sticky verticalmente */
        }

        /* Estilo espec√≠fico para el TH de "Canal" (la primera celda de la cabecera) */
        #grid-container th:first-child {
            background: #222 !important;
            z-index: 11;
            /* Asegura que est√© por encima de las celdas de programas y los otros THs */
            position: sticky;
            /* Hacemos que sea sticky horizontal y verticalmente */
            left: 0;
        }

        /* Estilo espec√≠fico para la celda de Canal (la primera de cada fila) */
        #grid-container td:first-child {
            position: sticky;
            left: 0;
            z-index: 9;
            /* Debe estar por debajo del TH fijo */
            background: #222 !important;
            /* Fondo fijo para modo oscuro */
        }

        /* Estilo espec√≠fico para la celda de Canal en modo claro */
        body.light-mode #grid-container th:first-child {
            background-color: #e0e0e0 !important;
            /* Fondo del encabezado de canal en modo claro */
            z-index: 11;
            position: sticky;
            left: 0;
        }

        /* --- Estilos del Loader en modo claro --- */
        body.light-mode #loader-spinner {
            border-color: var(--color-primary-hover);
            /* Color del spinner */
            border-top-color: transparent;
        }

        body.light-mode #loader p {
            color: var(--color-text-muted-light) !important;
            /* Texto del loader */
        }

        /* Responsive styles */
        @media (max-width: 768px) {
            body.light-mode .card-date {
                color: var(--color-text-muted-light) !important;
                /* Asegura el color en la vista de lista */
            }

            .card-body {
                flex-direction: column;
                align-items: flex-start;
            }

            .card-images {
                flex-direction: row;
                gap: 10px;
            }

            .card-images img {
                width: 70px;
                height: 90px;
                max-width: auto;
                width: auto;
                border-radius: 6px;
                object-fit: cover;
            }

            .card-channel {
                flex-direction: column-reverse;
                align-items: center;
            }

            input[type="text"],
            select,
            button {
                width: 90%;
                margin: 5px auto;
                display: block;
            }

            #controls {
                padding: 10px;
            }

            .card-info {
                flex-direction: column;
                align-items: flex-start;
            }

            .card-time {
                margin-top: 4px;
            }

        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>

</head>

<body>
    <h1>EPG dobleM</h1>

    <div id="top-buttons" style="text-align: center; margin-bottom: 20px; display: flex; justify-content: center; gap: 15px; flex-wrap: nowrap;">
        <button onclick="toggleViewMode()" id="viewToggleBtn" title="Cambiar vista">üìÖ</button>
        <button onclick="toggleDarkMode()" id="themeToggleBtn" title="Cambiar tema">üåô</button>
        <button onclick="fetchXML()" id="reloadBtn" title="Recargar EPG">üîÉ</button>
        <button id="uploadXmlBtn" title="Usar otro XML">üìÇ</button>
        <input accept=".xml" type="file" id="fileInput" style="display:none;" />
    </div>

    <div id="controls">
        <select id="channelDropdown">
            <option value="">Seleccionar Canal</option>
        </select>
        <input type="text" id="channelFilter" placeholder="Filtrar por Canal" />
        <input type="text" id="titleFilter" placeholder="Filtrar por T√≠tulo" />
        <input type="text" id="descriptionFilter" placeholder="Filtrar por Descripci√≥n" />
        <div id="dateHourGroup" style="display: inline-flex; gap: 8px; align-items: center;">
            <input type="date" id="dateFilter" />
            <select id="hourFilter">
                <option value="">Hora</option>
                <option value="0">00:00</option>
                <option value="1">01:00</option>
                <option value="2">02:00</option>
                <option value="3">03:00</option>
                <option value="4">04:00</option>
                <option value="5">05:00</option>
                <option value="6">06:00</option>
                <option value="7">07:00</option>
                <option value="8">08:00</option>
                <option value="9">09:00</option>
                <option value="10">10:00</option>
                <option value="11">11:00</option>
                <option value="12">12:00</option>
                <option value="13">13:00</option>
                <option value="14">14:00</option>
                <option value="15">15:00</option>
                <option value="16">16:00</option>
                <option value="17">17:00</option>
                <option value="18">18:00</option>
                <option value="19">19:00</option>
                <option value="20">20:00</option>
                <option value="21">21:00</option>
                <option value="22">22:00</option>
                <option value="23">23:00</option>
            </select>
            <button id="resetFiltersBtn" title="Resetear filtros">‚úñÔ∏èÔ∏è</button>
        </div>

    </div>

    <div id="grid-container" style="margin-top: 30px;"></div>


    <div id="loader" style="display: none; text-align:center; margin-top:20px;">
        <span id="loader-spinner"></span>
        <p style="color:#ccc;">Cargando EPG...</p>
    </div>

    <div id="data-list"></div>
    <div id="result-count"></div>

    <script>
        let epgData = [];
        let channelsList = [];
        let filteredData = [];
        let pageSize = 30;
        let renderedItems = 0;

        // Funci√≥n para obtener la fecha actual en formato YYYY-MM-DD
        function getCurrentDateFormatted() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0'); // Los meses son de 0-11
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Funci√≥n para establecer la fecha actual en el input de fecha
        function setDateToCurrent() {
            document.getElementById('dateFilter').value = getCurrentDateFormatted();
        }

        async function fetchXML() {
            const loader = document.getElementById('loader');
            const reloadBtn = document.querySelector('button[onclick="fetchXML()"]');
            reloadBtn.disabled = true;
            loader.style.display = 'block';

            try {
                const url = 'https://raw.githubusercontent.com/davidmuma/EPG_dobleM/master/EPG_dobleM.xml';
                const response = await fetch(url);
                if (!response.ok) throw new Error("No se pudo cargar el archivo EPG.");
                const xmlText = await response.text();

                // Parsear XML con promesa para no bloquear UI
                await new Promise(resolve => {
                    setTimeout(() => {
                        parseXML(xmlText);
                        resolve();
                    }, 50); // Permite que el loader se pinte antes del parseo pesado
                });

                // Mostrar los primeros 10 resultados r√°pido
                renderTable(true, 10);

                // Luego cargar el resto en background, sin bloquear UI
                setTimeout(() => {
                    renderTable(false);
                }, 100);

            } catch (err) {
                alert("Error al cargar el EPG: " + err.message);
            } finally {
                loader.style.display = 'none';
                reloadBtn.disabled = false;
            }
        }

        document.getElementById('fileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        parseXML(e.target.result);
                    } catch (err) {
                        alert("Error al analizar el archivo XML: " + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        function parseXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
            const parserError = xmlDoc.querySelector('parsererror');
            if (parserError) {
                console.error("Error XML:", parserError.textContent);
                throw new Error("El archivo XML contiene errores.");
            }
            const programmes = xmlDoc.getElementsByTagName('programme');
            epgData = [];

            const channels = {};
            const channelElements = xmlDoc.getElementsByTagName('channel');
            const tempChannelsSet = new Set(); // Usamos un Set para evitar duplicados
            channelsList = []; // Reiniciamos channelsList

            for (let i = 0; i < channelElements.length; i++) {
                const channel = channelElements[i];
                const channelId = channel.getAttribute('id');
                const iconSrc = channel.getElementsByTagName('icon')[0]?.getAttribute('src') || '';
                channels[channelId] = iconSrc;

                // Si el canal no ha sido a√±adido a√∫n, lo a√±adimos a la lista
                if (!tempChannelsSet.has(channelId)) {
                    tempChannelsSet.add(channelId);
                    channelsList.push(channelId); // A√±adir en el orden de aparici√≥n del XML
                }
            }

            // channelsList ahora contendr√° los IDs de los canales en el orden del XML, sin duplicados.
            populateChannelDropdown();

            for (let i = 0; i < programmes.length; i++) {
                const prog = programmes[i];
                const channel = prog.getAttribute('channel') || '';
                const date = formatXMLTVDate(prog.getAttribute('start'));
                const start = formatXMLTVTime(prog.getAttribute('start'));
                const stop = formatXMLTVTime(prog.getAttribute('stop'));
                const duration = calculateDuration(prog.getAttribute('start'), prog.getAttribute('stop'));
                const title = prog.getElementsByTagName('title')[0]?.textContent || '';
                const description = prog.getElementsByTagName('desc')[0]?.textContent || '';
                const iconSrc = prog.getElementsByTagName('icon')[0]?.getAttribute('src') || '';
                const iconSrc2 = prog.getElementsByTagName('icon2')[0]?.getAttribute('src') || '';
                const channelIcon = channels[channel] || '';

                epgData.push({
                    channel,
                    channelIcon,
                    date,
                    start,
                    stop,
                    duration,
                    iconSrc,
                    iconSrc2,
                    title,
                    description
                });
            }

            renderTable(true);
        }

        // ‚úÖ Nueva funci√≥n: convierte una fecha EPG (con zona horaria) a objeto Date
        function parseEPGDate(epgDateStr) {
            // Ejemplo de entrada: "20251116060000 +0100"
            const match = epgDateStr.match(/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2}) ([\+\-]\d{4})$/);
            if (!match) return null;

            const [_, y, mo, d, h, mi, s, tz] = match;
            // Convertimos a formato ISO con zona horaria
            const isoString = `${y}-${mo}-${d}T${h}:${mi}:${s}${tz.slice(0, 3)}:${tz.slice(3)}`;
            return new Date(isoString);
        }

        // ‚úÖ Nueva funci√≥n: formatea la fecha (dd/mm/yyyy)
        function formatXMLTVDate(epgDateStr) {
            const date = parseEPGDate(epgDateStr);
            if (!date) return '';
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        }

        // ‚úÖ Nueva funci√≥n: formatea la hora local (hh:mm)
        function formatXMLTVTime(epgDateStr) {
            const date = parseEPGDate(epgDateStr);
            if (!date) return '';
            const hour = String(date.getHours()).padStart(2, '0');
            const minute = String(date.getMinutes()).padStart(2, '0');
            return `${hour}:${minute}`;
        }

        // ‚úÖ Ajuste de calculateDuration para que use la nueva funci√≥n
        function calculateDuration(start, stop) {
            const startDate = parseEPGDate(start);
            const stopDate = parseEPGDate(stop);
            if (!startDate || !stopDate) return '';

            let diffMs = stopDate - startDate;
            const diffMins = Math.floor(diffMs / 60000);
            const hours = Math.floor(diffMins / 60);
            const minutes = diffMins % 60;

            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }

        function populateChannelDropdown() {
            const dropdown = document.getElementById('channelDropdown');
            dropdown.innerHTML = '<option value="">Seleccionar Canal</option>';
            channelsList.forEach(channelId => {
                const option = document.createElement('option');
                option.value = channelId;
                option.textContent = channelId;
                dropdown.appendChild(option);
            });
        }

        function processColoredText(text) {
            if (!text) return ''; // Manejar el caso de texto vac√≠o o nulo

            // Expresi√≥n regular para encontrar [COLOR X]...[/COLOR]
            // Captura el nombre del color (grupo 1) y el contenido (grupo 2)
            const regex = /\[COLOR\s*(\w+)\](.*?)\[\/COLOR\]/g;

            // Reemplaza cada coincidencia con una etiqueta <span> con estilo inline
            const processedText = text.replace(regex, (match, colorName, content) => {
                // Puedes a√±adir una lista de colores v√°lidos o mapear a clases CSS
                // Por simplicidad, aqu√≠ usamos el nombre directamente como color CSS
                return `<span style="color: ${colorName};">${content}</span>`;
            });

            return processedText;
        }

 function renderTable(initial = false) {
    const dataList = document.getElementById('data-list');
    const resultCount = document.getElementById('result-count');

    if (initial) {
        const filters = {
            channel: document.getElementById('channelFilter').value.toLowerCase(),
            title: document.getElementById('titleFilter').value.toLowerCase(),
            description: document.getElementById('descriptionFilter').value.toLowerCase(),
            date: document.getElementById('dateFilter').value,
            hour: document.getElementById('hourFilter').value
        };

        filteredData = epgData.filter(item => {
            if (filters.channel && !item.channel.toLowerCase().includes(filters.channel)) return false;
            if (filters.title && !item.title.toLowerCase().includes(filters.title)) return false;
            if (filters.description && !item.description.toLowerCase().includes(filters.description)) return false;

            if (filters.date) {
                const parts = item.date.split('/');
                const itemDateFormatted = parts.length === 3 ? `${parts[2]}-${parts[1]}-${parts[0]}` : '';
                if (itemDateFormatted !== filters.date) return false;
            }

            if (filters.hour !== '') {
                const filterHour = parseInt(filters.hour, 10);
                if (isNaN(filterHour) || filterHour < 0 || filterHour > 23) return false;
                const itemHour = parseInt(item.start.split(':')[0], 10);
                if (isNaN(itemHour)) return false;
                const itemStopHour = parseInt(item.stop.split(':')[0], 10);
                if (!isNaN(itemStopHour) && itemHour < filterHour && itemStopHour >= filterHour) return true;
                return itemHour >= filterHour;
            }

            return true;
        });

        // -------------------------------
        // ORDENAR CANALES POR LONGITUD
        // -------------------------------
        if (filters.channel) {
            filteredData.sort((a, b) => {
                const aIncludes = a.channel.toLowerCase().includes(filters.channel);
                const bIncludes = b.channel.toLowerCase().includes(filters.channel);
                // Primero los que incluyen la b√∫squeda
                if (aIncludes && !bIncludes) return -1;
                if (!aIncludes && bIncludes) return 1;
                // Si ambos incluyen, ordenar por longitud del nombre
                if (aIncludes && bIncludes) return a.channel.length - b.channel.length;
                return 0; // si ninguno incluye, dejar igual
            });
        }

        renderedItems = 0;
        dataList.innerHTML = '';
        const initialChunk = filteredData.slice(0, pageSize);
        renderChunk(initialChunk);
        renderedItems += initialChunk.length;

    } else {
        if (renderedItems < filteredData.length) {
            const nextChunk = filteredData.slice(renderedItems, renderedItems + pageSize);
            renderChunk(nextChunk);
            renderedItems += nextChunk.length;
        }
    }

    resultCount.textContent = `Mostrando ${filteredData.length} programas`;
}

        let gridView = false;

        function toggleViewMode() {
            gridView = !gridView;
            document.getElementById('data-list').style.display = gridView ? 'none' : 'block';
            document.getElementById('grid-container').style.display = gridView ? 'block' : 'none';
            document.getElementById('viewToggleBtn').textContent = gridView ? 'üìã' : 'üìÖ';
            if (gridView) {
                renderCurrentView();
            }
        }

function renderCurrentView() {
    if (gridView) {
        document.getElementById('data-list').style.display = 'none';
        document.getElementById('grid-container').style.display = 'block';

        const filters = {
            channel: document.getElementById('channelFilter').value.toLowerCase(),
            title: document.getElementById('titleFilter').value.toLowerCase(),
            description: document.getElementById('descriptionFilter').value.toLowerCase(),
            date: document.getElementById('dateFilter').value,
            hour: document.getElementById('hourFilter').value
        };

        filteredData = epgData.filter(item => {
            if (filters.channel && !item.channel.toLowerCase().includes(filters.channel)) return false;
            if (filters.title && !item.title.toLowerCase().includes(filters.title)) return false;
            if (filters.description && !item.description.toLowerCase().includes(filters.description)) return false;

            if (filters.date) {
                const parts = item.date.split('/');
                const itemDateFormatted = parts.length === 3 ? `${parts[2]}-${parts[1]}-${parts[0]}` : '';
                if (itemDateFormatted !== filters.date) return false;
            }

            if (filters.hour !== '') {
                const filterHour = parseInt(filters.hour, 10);
                if (isNaN(filterHour) || filterHour < 0 || filterHour > 23) return false;
                const itemHour = parseInt(item.start.split(':')[0], 10);
                if (isNaN(itemHour)) return false;
                const itemStopHour = parseInt(item.stop.split(':')[0], 10);
                if (!isNaN(itemStopHour) && itemHour < filterHour && itemStopHour >= filterHour) return true;
                return itemHour >= filterHour;
            }

            return true;
        });

        // -------------------------------
        // ORDENAR CANALES POR LONGITUD
        // -------------------------------
        if (filters.channel) {
            filteredData.sort((a, b) => {
                const aIncludes = a.channel.toLowerCase().includes(filters.channel);
                const bIncludes = b.channel.toLowerCase().includes(filters.channel);
                if (aIncludes && !bIncludes) return -1;
                if (!aIncludes && bIncludes) return 1;
                if (aIncludes && bIncludes) return a.channel.length - b.channel.length;
                return 0;
            });
        }

        renderGridView();
        document.getElementById('result-count').textContent = `Mostrando ${filteredData.length} programas`;

    } else {
        document.getElementById('grid-container').style.display = 'none';
        document.getElementById('data-list').style.display = 'flex';
        renderTable(true);
    }
}


        function renderGridView() {
            const container = document.getElementById('grid-container');
            container.innerHTML = '';

            const grouped = {};
            filteredData.forEach(item => {
                if (!grouped[item.channel]) grouped[item.channel] = [];
                grouped[item.channel].push(item);
            });

            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.tableLayout = 'fixed';

            const hoursRow = document.createElement('tr');
            hoursRow.innerHTML = `<th style="width: 120px; white-space: nowrap;">Canal</th>`;
            for (let h = 0; h < 24; h++) {
                hoursRow.innerHTML += `<th style="width: 150px; font-size: 0.8em;">${String(h).padStart(2, '0')}:00</th>`;
            }
            table.appendChild(hoursRow);

            // Filtrar channelsList para incluir solo los canales que tienen programas actualmente filtrados
            // Pero ahora, channelsList ya tiene el orden del XML
            const channelsInFilteredData = new Set(filteredData.map(item => item.channel));
            const sortedChannels = channelsList.filter(channel => channelsInFilteredData.has(channel));

            for (const channel of sortedChannels) {
                const programs = grouped[channel];

                if (!programs || programs.length === 0) {
                    continue;
                }

                const row = document.createElement('tr');

                const channelCell = document.createElement('td');
                channelCell.style.padding = '5px';
                channelCell.style.background = '#222';
                channelCell.style.color = '#FFFFFF';
                channelCell.style.verticalAlign = 'middle';

                const channelIconSrc = programs[0]?.channelIcon || '';
                const channelName = channel;

                if (channelIconSrc) {
                    const img = document.createElement('img');
                    img.src = channelIconSrc;
                    img.alt = channelName;
                    img.style.height = '32px';
                    img.style.width = 'auto';
                    img.style.maxWidth = '60px';
                    img.style.display = 'block';
                    img.style.margin = '0 auto 2px auto';
                    channelCell.appendChild(img);
                }

                const nameDiv = document.createElement('div');
                nameDiv.textContent = channelName;
                nameDiv.style.fontSize = '0.75em';
                nameDiv.style.textAlign = 'center';
                channelCell.appendChild(nameDiv);

                row.appendChild(channelCell);

                const cells = new Array(24).fill(null);

                programs.forEach(program => {
                    const startHour = parseInt(program.start.split(':')[0], 10);
                    const dateParts = program.date.split('/');
                    const formattedDate = `${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`;
                    const startTime = new Date(`${formattedDate}T${program.start}:00`);
                    const stopTime = new Date(`${formattedDate}T${program.stop}:00`);
                    const diffMinutes = Math.round((stopTime - startTime) / 60000);
                    const durationInHours = Math.max(1, diffMinutes / 60);

                    const title = program.title || '';
                    const col = document.createElement('td');
                    col.colSpan = Math.max(1, Math.round(durationInHours));

                    col.style.background = '#333';
                    col.style.color = '#fff';
                    col.style.textAlign = 'center';
                    col.style.border = '1px solid #444';
                    col.style.padding = '2px';
                    col.style.overflow = 'hidden';
                    col.style.verticalAlign = 'top';
                    col.style.whiteSpace = 'normal';
                    col.style.wordWrap = 'break-word';

                    const titleDiv = document.createElement('div');
                    titleDiv.innerHTML = processColoredText(title);
                    titleDiv.style.fontWeight = 'bold';
                    titleDiv.style.fontSize = '0.85em';
                    col.appendChild(titleDiv);

                    const timeDiv = document.createElement('div');
                    timeDiv.textContent = `${program.date} ${program.start} - ${program.stop}`;
                    timeDiv.style.fontSize = '0.7em';
                    timeDiv.style.color = '#ccc';
                    timeDiv.style.marginTop = '2px';
                    col.appendChild(timeDiv);

                    cells[startHour] = col;

                    for (let i = 1; i < col.colSpan; i++) {
                        if (startHour + i < 24) {
                            cells[startHour + i] = 'occupied';
                        }
                    }
                });

                for (let h = 0; h < 24; h++) {
                    if (cells[h] && cells[h] !== 'occupied') {
                        row.appendChild(cells[h]);
                        h += cells[h].colSpan - 1;
                    } else if (cells[h] === null) {
                        const empty = document.createElement('td');
                        empty.style.border = '1px solid #444';
                        empty.innerHTML = '&nbsp;';
                        row.appendChild(empty);
                    }
                }

                table.appendChild(row);
            }

            container.appendChild(table);
        }

        function renderChunk(data) {
            const dataList = document.getElementById('data-list');
            data.forEach(item => {
                const card = document.createElement('div');
                card.className = 'program-card';
                card.innerHTML = `
          <div class="card-header">
            <div class="card-info">
              <div class="card-date">${item.date}</div>
              <div class="card-time">${item.start} - ${item.stop} ${item.duration ? `<span class="duration">(${item.duration})</span>` : ''}</div>
            </div>
            <div class="card-channel">
              ${item.channelIcon ? `<img src="${item.channelIcon}" alt="${item.channel}">` : ''}
              <div class="channel-name">${item.channel}</div>
            </div>
          </div>
          <div class="card-body">
            <div class="card-images">
              ${item.iconSrc ? `<img src="${item.iconSrc}" alt="Imagen de ${item.title}">` : ''}
              ${item.iconSrc2 ? `<img src="${item.iconSrc2}" alt="Imagen 2 de ${item.title}">` : ''}
            </div>
            <div class="card-text">
              <div class="title">${processColoredText(item.title)}</div>
              <div class="description">${processColoredText(item.description)}</div>
            </div>
          </div>
        `;
                dataList.appendChild(card);
            });
        }

        function toggleDarkMode() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            document.getElementById('themeToggleBtn').textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
        }

        document.getElementById('uploadXmlBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        // Filtros
        document.getElementById('channelDropdown').addEventListener('input', () => {
            document.getElementById('channelFilter').value = document.getElementById('channelDropdown').value;
            renderCurrentView();
        });

        document.getElementById('dateFilter').addEventListener('input', () => {
            renderTable(true);
        });

        document.getElementById('hourFilter').addEventListener('input', () => {
            renderTable(true);
        });

        document.getElementById('resetFiltersBtn').addEventListener('click', () => {
            // Limpiar todos los filtros
            document.getElementById('channelDropdown').value = '';
            document.getElementById('channelFilter').value = '';
            document.getElementById('titleFilter').value = '';
            document.getElementById('descriptionFilter').value = '';
            // Establecer la fecha al d√≠a actual
            setDateToCurrent();
            document.getElementById('hourFilter').value = '';
            renderCurrentView();
        });


        // Evitar renderizados excesivos con debounce
        function debounce(func, delay = 300) {
            let timer;
            return function(...args) {
                clearTimeout(timer);
                timer = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // Aplica debounce a los filtros de texto
        ['channelFilter', 'titleFilter', 'descriptionFilter', 'dateFilter', 'hourFilter'].forEach(id => {
            document.getElementById(id).addEventListener('input', debounce(() => {
                document.getElementById('channelDropdown').value = '';
                renderCurrentView();
            }));
        });

        // IMPORTANTE: Modifica tu listener de scroll ligeramente si decides renderizar todo en el filtro inicial
        window.addEventListener('scroll', () => {
            // Solo aplica el scroll infinito si estamos en la vista de lista Y no todos los elementos filtrados est√°n renderizados
            if (!gridView && (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 200) && renderedItems < filteredData.length) {
                renderTable(false); // Cargamos m√°s si estamos en la vista de lista y no se muestran todos los elementos
            }
        });

        // Llama a setDateToCurrent al cargar la p√°gina para establecer la fecha inicial
        document.addEventListener('DOMContentLoaded', setDateToCurrent);

        fetchXML();
    </script>
</body>

</html>
